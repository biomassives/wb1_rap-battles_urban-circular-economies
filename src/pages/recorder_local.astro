---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout title="Local Bio-Recorder" description="Offline-first audio capture using IndexedDB">

<style>
  :root {
    --nile-green: #00ffcc;
    --panel-bg: #121214;
  }

  .recorder-shell { max-width: 900px; margin: 2rem auto; font-family: sans-serif; }

  .band {
    display: flex;
    align-items: center;
    gap: 1rem;
    background: var(--panel-bg);
    padding: 1rem;
    border-radius: 12px;
    border: 1px solid #333;
  }

  .vis-container { flex-grow: 1; height: 60px; background: #000; border-radius: 6px; overflow: hidden; }
  canvas { width: 100%; height: 100%; }

  .btn {
    padding: 12px 20px;
    border-radius: 8px;
    border: none;
    font-weight: bold;
    cursor: pointer;
  }

  .btn-rec { background: #ff4444; color: white; }
  .btn-rec.active { animation: pulse 1.5s infinite; }
  .btn-save { background: var(--nile-green); color: black; }
  .btn-save:disabled { opacity: 0.3; }

  .track-list { margin-top: 2rem; }
  .track-item {
    background: #222;
    margin-bottom: 0.5rem;
    padding: 0.75rem;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: white;
  }

  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
</style>

<div class="recorder-shell">
  <div class="band">
    <button id="rec-btn" class="btn btn-rec">● REC</button>
    <div class="vis-container"><canvas id="canvas"></canvas></div>
    <button id="save-btn" class="btn btn-save" disabled>SAVE TRACK</button>
  </div>

  <div class="track-list">
    <h3>Local Library (IndexedDB)</h3>
    <div id="library-root"></div>
  </div>
</div>

<script>
  /**
   * 1. DATABASE ENGINE (IndexedDB)
   * No configuration needed. Works in every modern browser.
   **/
  const DB_NAME = "BioStore";
  const STORE_NAME = "tracks";

  function initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, 1);
      request.onupgradeneeded = (e) => {
        e.target.result.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject("DB Error");
    });
  }

  async function saveTrack(blob, name) {
    const db = await initDB();
    const tx = db.transaction(STORE_NAME, "readwrite");
    tx.objectStore(STORE_NAME).add({ blob, name, date: new Date() });
    return new Promise(r => tx.oncomplete = r);
  }

  async function getTracks() {
    const db = await initDB();
    const tx = db.transaction(STORE_NAME, "readonly");
    const store = tx.objectStore(STORE_NAME);
    return new Promise(r => {
      store.getAll().onsuccess = (e) => r(e.target.result);
    });
  }

  /**
   * 2. AUDIO & VISUALS
   **/
  let mediaRecorder, chunks = [], audioCtx, animationId;
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function draw(stream) {
    audioCtx = new AudioContext();
    const source = audioCtx.createMediaStreamSource(stream);
    const analyser = audioCtx.createAnalyser();
    source.connect(analyser);
    const data = new Uint8Array(analyser.frequencyBinCount);

    const render = () => {
      animationId = requestAnimationFrame(render);
      analyser.getByteFrequencyData(data);
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00ffcc';
      data.forEach((val, i) => {
        const h = (val / 255) * canvas.height;
        ctx.fillRect(i * 3, canvas.height - h, 2, h);
      });
    };
    render();
  }

  /**
   * 3. UI LOGIC
   **/
  const recBtn = document.getElementById('rec-btn');
  const saveBtn = document.getElementById('save-btn');
  const library = document.getElementById('library-root');

  recBtn.onclick = async () => {
    if (recBtn.classList.contains('active')) {
      mediaRecorder.stop();
      cancelAnimationFrame(animationId);
      recBtn.classList.remove('active');
      recBtn.innerText = "● REC";
      saveBtn.disabled = false;
    } else {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      draw(stream);
      mediaRecorder = new MediaRecorder(stream);
      chunks = [];
      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.start();
      recBtn.classList.add('active');
      recBtn.innerText = "⏹ STOP";
      saveBtn.disabled = true;
    }
  };

  saveBtn.onclick = async () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    const name = `Recording ${new Date().toLocaleTimeString()}`;
    await saveTrack(blob, name);
    saveBtn.disabled = true;
    renderLibrary();
  };

  async function renderLibrary() {
    const tracks = await getTracks();
    library.innerHTML = tracks.map(t => `
      <div class="track-item">
        <span>${t.name}</span>
        <audio src="${URL.createObjectURL(t.blob)}" controls></audio>
      </div>
    `).reverse().join('');
  }

  // Initial load
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  renderLibrary();
</script>

</BaseLayout>
