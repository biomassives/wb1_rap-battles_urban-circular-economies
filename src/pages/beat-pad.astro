---
/**
 * Beat Pad - Simplified Sampler
 * Space Invaders Retro Theme
 * Maximum pad space, minimal header
 */

import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
  title="Beat Pad"
  description="Retro beat sampler pads"
  activeSection="music"
>
  <div class="beat-pad-container">

    <!-- Minimal Retro Header with Strudel -->
    <header class="retro-header">
      <div class="header-left">
        <h1 class="retro-title">‚ó¢ BEAT PAD ‚ó£</h1>
        <div class="score-display">BPM: <span id="header-bpm">120</span></div>
      </div>

      <!-- Strudel Display -->
      <div class="strudel-display">
        <button id="strudel-toggle" class="strudel-toggle">
          ‚ñº STRUDEL CODE
        </button>
      </div>

      <nav class="header-nav">
        <a href="/battle" class="nav-btn">BATTLE</a>
        <a href="/profile" class="nav-btn">PROFILE</a>
        <a href="/" class="nav-btn">HOME</a>
      </nav>
    </header>

    <!-- Strudel Code Panel (Expandable) -->
    <div id="strudel-panel" class="strudel-panel collapsed">
      <div class="strudel-panel-inner">

        <!-- Controls Row -->
        <div class="strudel-controls-row">
          <div class="control-group">
            <button id="strudel-play" class="strudel-btn play">‚ñ∂ PLAY</button>
            <button id="strudel-stop" class="strudel-btn">‚ñ† STOP</button>
          </div>

          <div class="control-group">
            <label class="strudel-label">PRESETS:</label>
            <select id="strudel-pattern" class="strudel-select">
              <option value='sound("bd sd")'>808 BASIC</option>
              <option value='sound("bd hh sd hh")'>808 GROOVE</option>
              <option value='sound("bd sd cp hh")'>808 FULL</option>
              <option value='s(
mix(
kit("808").kick.seq("x---x-x-","x-x-x---","x---x-x-","x-x-x---"),
kit("808").snare.seq("-x---x--","-x---x--","-x---x--","-x---x--")
.add(kit("808").snare.seq("----x---x---x---").offset(12)),
kit("808").hihat.seq("x-x-x-x-x-x-x-x-","x-x-x-x-x-x-x-x-","x-x-x-x-x-x-x-x-","x-x-x-x-x-x-x-x-"),
kit("808").hihat.open.seq("--------x-------","--------x-------","--------x-------","--------x-------"),

synth("sub")
  .gain(0.8).filter.lowpass(120)
  .seq(
    "C2---","C2---","C2---","C2---",
    "C2---","C2---","C2---","C2---",
    "C2---","C2---","C2---","C2---",
    "C2---","C2---","C2---","C2---"
  )
  .sidechain(kit("808").kick,0.3),

synth("saw")
  .gain(0.6).filter.lowpass(900)
  .seq(
    "C4-Eb4-G4-Bb4-A4-G4-F4-Eb4",
    "D4-F4-A4-C5-B4-A4-G4-F4"
  )
  .delay(0.25,0.45),

synth("lead")
  .gain(0.4).filter.lowpass(1500)
  .seq(
    // 16th‚Äënote arpeggio over a minor 7th
    "E4-G4-Bb4-D5-E5-D5-Bb4-G4",
    "E4-G4-Bb4-D5-E5-D5-Bb4-G4"
  )
  .reverb(0.6),

sample("vocals/yeah.wav")
  .gain(0.7).seq("----x---","----x---","----x---","----x---")
  .pitch(1.2),

sample("breakbeat/stab.wav")
  .gain(0.6).filter.lowpass(1500)
  .seq("----x---","----x---","----x---","----x---")
)
.add(
synth("saw")
.gain(0.4).filter.lowpass(200)
.seq("----","----")
.fadeIn(0.5)
.add(sample("vocals/yo.wav").gain(0.5).seq("x---"))
)
.fadeOut(8)
)'>SLANG TANG RESPONSE</option>
              <option value='s("bd cp")'>BOOM BAP</option>
              s(
mix(
// -------------------------------------------------
// 1Ô∏è‚É£  Fast‚Äëbreak 180‚ÄØBPM  (4/4 ‚Üí 8‚Äëstep hi‚Äëhat)
// -------------------------------------------------
kit("drum-machines").kick.seq(
"x---x---x---x---",   // steady 4‚Äëon‚Äëthe‚Äëfloor
"x---x---x---x---"
),
kit("drum-machines").snare.seq(
"-x---x---x---x---",  // snare on 2‚ÄØ&‚ÄØ4, plus extra ghost hits
"-x---x---x---x---"
),
kit("drum-machines").hihat.seq(
"x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-",   // 16th‚Äënote roll
"x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-"
),
// -------------------------------------------------
// 2Ô∏è‚É£  Granular gritty bass (noise‚Äëgrain synth)
// -------------------------------------------------
synth("granular")
.gain(0.7)
.filter.lowpass(300)          // keep it deep but gritty
.grainSize(0.02)               // short grains for texture
.pitchEnv([0, 0.2, -0.1, 0])   // wobble pitch envelope
.seq(
"C2---C2---C2---C2---",
"C2---C2---C2---C2---"
)
.sidechain(kit("drum-machines").kick, 0.25),

Code

Copy Code
// -------------------------------------------------
// 3Ô∏è‚É£  Lead ‚Äì high‚Äëpitched, distorted saw with 32nd‚Äënote runs
// -------------------------------------------------
synth("saw")
  .gain(0.5)
  .filter.lowpass(1800)
  .distort(0.6)
  .seq(
    // 2‚Äëbar phrase, each bar filled with 32nd‚Äënote arpeggio
    "E5-G5-B5-D6-E6-D6-B5-G5",
    "F5-A5-C6-E6-F6-E6-C6-A5"
  )
  .delay(0.15, 0.35),

// -------------------------------------------------
// 4Ô∏è‚É£  Sample stabs ‚Äì short, reversed, filtered glitch
// -------------------------------------------------
sample("glitch/reverse.wav")
  .gain(0.6)
  .filter.highpass(1200)
  .seq("----x---x---x---","----x---x---x---")
)
// -------------------------------------------------
// 5Ô∏è‚É£  Intro/Outro ‚Äì filtered sweep + quick fade
// -------------------------------------------------
.add(
synth("sine")
.gain(0.4)
.filter.lowpass(400)
.seq("----","----")
.fadeIn(0.3)
)
.fadeOut(6)
)'>180 bpm</option>
              <option value='s("bd sd hh oh")'>HIP HOP</option>
              <option value='s("bd lt sd ht")'>TOMS BEAT</option>
              <option value='s("hh hh oh hh")'>HI-HATS</option>
              <option value='s("bd rim sd rim")'>RIMSHOT</option>
              <option value='note("c a f e").s("piano")'>CAFE MELODY</option>
            </select>
            <button id="strudel-load" class="strudel-btn">LOAD</button>
            <button id="reload-samples" class="strudel-btn" title="Reload audio samples">üîÑ</button>
          </div>

          <div class="control-group">
            <span class="strudel-status" id="strudel-status">READY</span>
          </div>
        </div>

        <!-- Main Content: Code + Visualizer -->
        <div class="strudel-content">

          <!-- Code Editor -->
          <div class="strudel-code-section">
            <div class="code-header">
              <span class="code-label">‚ó¢ STRUDEL CODE ‚ó£</span>
              <button id="code-clear" class="code-btn">CLEAR</button>
            </div>
            <textarea
              id="strudel-code"
              class="strudel-code-editor"
              placeholder="// Enter pattern code here...
// Examples:
// sound(&quot;bd sd&quot;)          - Drum pattern
// note(&quot;c a f e&quot;).s(&quot;piano&quot;) - Melody
// s(&quot;bd sd hh&quot;)            - Short form
"
              spellcheck="false"
            >sound("bd sd")</textarea>
            <div class="code-footer">
              <span class="code-hint">Press CTRL+ENTER to evaluate | ESC to stop</span>
            </div>
          </div>

          <!-- Visualizer -->
          <div class="strudel-viz-section">
            <div class="viz-header">
              <span class="viz-label">‚ó¢ VISUALIZER ‚ó£</span>
              <span class="viz-cycle" id="viz-cycle">CYCLE: 0</span>
            </div>
            <div id="strudel-visualizer" class="strudel-viz">
              <canvas id="strudel-canvas" class="strudel-canvas"></canvas>
            </div>
            <div class="strudel-pattern-display" id="pattern-display">
              <div class="pattern-text">Waiting for pattern...</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Main Pad Area -->
    <main class="pad-area">

      <!-- Compact Controls Strip -->
      <div class="controls-strip">
        <div class="control-group">
          <button id="play-btn" class="ctrl-btn">‚ñ∂</button>
          <button id="stop-btn" class="ctrl-btn">‚ñ†</button>
          <button id="record-btn" class="ctrl-btn record">‚óè</button>
        </div>

        <div class="control-group">
          <button id="bpm-down" class="ctrl-btn small">-</button>
          <input type="number" id="bpm-input" value="120" min="60" max="200" />
          <button id="bpm-up" class="ctrl-btn small">+</button>
        </div>

        <div class="control-group">
          <select id="bank-select" class="bank-select">
            <option value="drums">DRUMS</option>
            <option value="synth">SYNTH</option>
            <option value="bass">BASS</option>
            <option value="fx">FX</option>
          </select>
        </div>

        <div class="control-group">
          <button id="clear-btn" class="ctrl-btn">CLEAR</button>
          <button id="export-btn" class="ctrl-btn">SAVE</button>
        </div>

        <div class="control-group">
          <span class="voices">VOICES: <span id="voice-count">0/8</span></span>
        </div>
      </div>

      <!-- 16 Pads Grid -->
      <div id="sampler-pads" class="pads-grid">
        <!-- Generated by JS -->
      </div>

    </main>

  </div>
</BaseLayout>

<script>
console.log('üéÆ Beat Pad loading...');

/**
 * Simplified Sampler - Space Invaders Theme
 */
class BeatPad {
  constructor() {
    this.audioContext = null;
    this.pads = [];
    this.selectedPad = null;
    this.bpm = 120;
    this.isPlaying = false;
    this.isRecording = false;
    this.currentStep = 0;
    this.sequencerData = [];
    this.masterVolume = 0.9;
    this.intervalId = null;
    this.currentBank = 'drums';

    // Performance
    this.activeOscillators = [];
    this.maxPolyphony = 8;

    // Sound banks
    this.soundBanks = {
      drums: [
        55,   // Kick
        180,  // Snare
        380,  // Hi-hat
        280,  // Clap
        90,   // Tom 1
        110,  // Tom 2
        580,  // Crash
        480,  // Ride
        75,   // Floor Tom
        140,  // Rim
        240,  // Cowbell
        340,  // Wood
        170,  // Clave
        210,  // Tamb
        270,  // Shake
        310   // Caba
      ],
      synth: [
        261.63, 293.66, 329.63, 349.23, // C D E F
        392.00, 440.00, 493.88, 523.25, // G A B C
        587.33, 659.25, 698.46, 783.99, // D E F G
        880.00, 987.77, 1046.50, 1174.66 // A B C D
      ],
      bass: [
        55, 58, 62, 65, 69, 73, 77, 82,
        87, 92, 98, 103, 110, 116, 123, 130
      ],
      fx: [
        200, 400, 600, 800, 1000, 1200, 1400, 1600,
        300, 500, 700, 900, 1100, 1300, 1500, 1700
      ]
    };

    this.padNames = [
      'KICK', 'SNARE', 'HIHAT', 'CLAP',
      'TOM1', 'TOM2', 'CRASH', 'RIDE',
      'TOM3', 'RIM', 'BELL', 'WOOD',
      'CLAV', 'TAMB', 'SHAKE', 'CABA'
    ];

    this.init();
  }

  async init() {
    console.log('üéõÔ∏è Initializing Beat Pad...');

    // Audio Context
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      console.log('‚úÖ Audio ready');
    } catch (error) {
      console.error('‚ùå Audio error:', error);
      return;
    }

    // Initialize sequencer
    for (let i = 0; i < 16; i++) {
      this.sequencerData[i] = new Array(16).fill(false);
    }

    // Generate pads
    this.generatePads();
    this.setupEventListeners();

    console.log('‚úÖ Beat Pad ready');
  }

  generatePads() {
    const padGrid = document.getElementById('sampler-pads');
    if (!padGrid) {
      console.error('‚ùå Pad grid not found');
      return;
    }

    // Clear existing
    padGrid.innerHTML = '';
    this.pads = [];

    // Gold to Bronze gradient colors for borders
    const borderColors = [
      '#FFD700', // Gold 1
      '#FFC700', // Gold 2
      '#FFB700', // Gold 3
      '#FFA700', // Orange-gold
      '#FF9700', // Deep gold
      '#FF8700', // Bronze 1
      '#E67E22', // Bronze 2
      '#D68910', // Bronze 3
      '#CD7F32', // Classic bronze
      '#C87533', // Bronze 4
      '#B8860B', // Dark goldenrod
      '#DAA520', // Goldenrod
      '#F4A460', // Sandy bronze
      '#D2691E', // Chocolate bronze
      '#B87333', // Copper bronze
      '#8B4513'  // Saddle brown bronze
    ];

    for (let i = 0; i < 16; i++) {
      const pad = document.createElement('div');
      pad.className = 'pad';
      pad.dataset.index = i;
      pad.style.setProperty('--border-color', borderColors[i]);

      pad.innerHTML = `
        <div class="pad-glow"></div>
        <div class="pad-inner">
          <div class="pad-num">${(i + 1).toString().padStart(2, '0')}</div>
          <div class="pad-name">${this.padNames[i]}</div>
        </div>
      `;

      // Click to play
      pad.addEventListener('click', () => {
        this.selectPad(i);
        this.playPad(i);
      });

      // Keyboard support
      pad.dataset.key = (i + 1).toString();

      padGrid.appendChild(pad);
      this.pads.push(pad);
    }

    console.log(`‚úÖ Generated ${this.pads.length} pads`);
  }

  selectPad(index) {
    this.pads.forEach(p => p.classList.remove('selected'));
    this.selectedPad = index;
    this.pads[index].classList.add('selected');
  }

  playPad(index) {
    const pad = this.pads[index];
    if (!pad) return;

    // Visual feedback
    pad.classList.add('active');
    setTimeout(() => pad.classList.remove('active'), 150);

    // If recording, add to sequence
    if (this.isRecording && this.isPlaying) {
      this.sequencerData[index][this.currentStep] = true;
    }

    // Play sound
    this.playSound(index);

    console.log(`üéµ ${this.padNames[index]}`);
  }

  playSound(index) {
    if (!this.audioContext) return;

    // Resume if suspended
    if (this.audioContext.state === 'suspended') {
      this.audioContext.resume().then(() => this.playSound(index));
      return;
    }

    // Polyphony limiting
    if (this.activeOscillators.length >= this.maxPolyphony) {
      const oldest = this.activeOscillators.shift();
      if (oldest?.osc) {
        try {
          oldest.osc.stop();
          oldest.osc.disconnect();
        } catch (e) {}
      }
    }

    // Calculate grid position (0-3 for both x and y)
    const row = Math.floor(index / 4); // Y: 0-3 (top to bottom)
    const col = index % 4;              // X: 0-3 (left to right)

    // Base frequency from sound bank
    const baseFreq = this.soundBanks[this.currentBank][index];
    const now = this.audioContext.currentTime;

    try {
      const osc = this.audioContext.createOscillator();
      const gain = this.audioContext.createGain();
      const filter = this.audioContext.createBiquadFilter();

      // Waveform
      const waveforms = {
        drums: 'triangle',
        synth: 'sine',
        bass: 'sawtooth',
        fx: 'square'
      };

      osc.type = waveforms[this.currentBank] || 'sine';

      // X-axis variation: Pitch shift (left=lower, right=higher)
      // Range: -200 cents to +200 cents (1 semitone = 100 cents)
      const pitchShift = (col - 1.5) * 100; // -150, -50, +50, +150 cents
      const pitchMultiplier = Math.pow(2, pitchShift / 1200);
      osc.frequency.value = baseFreq * pitchMultiplier;

      // Y-axis variation: Filter cutoff (top=bright, bottom=dark)
      filter.type = 'lowpass';
      const filterFreq = 20000 - (row * 4000); // 20kHz ‚Üí 8kHz
      filter.frequency.value = filterFreq;
      filter.Q.value = 1 + (row * 0.5); // Resonance increases downward

      // Envelope - varies with Y position
      const attackTime = row * 0.01; // 0ms to 30ms attack
      const decayTime = 0.3 + (row * 0.1); // Longer decay as you go down

      gain.gain.setValueAtTime(0.01, now);
      gain.gain.linearRampToValueAtTime(this.masterVolume, now + attackTime);
      gain.gain.exponentialRampToValueAtTime(0.01, now + decayTime);

      // Connect audio chain
      osc.connect(filter);
      filter.connect(gain);
      gain.connect(this.audioContext.destination);

      osc.start(now);
      osc.stop(now + decayTime);

      this.activeOscillators.push({ osc, stopTime: now + decayTime });

      setTimeout(() => {
        const idx = this.activeOscillators.findIndex(o => o.osc === osc);
        if (idx !== -1) this.activeOscillators.splice(idx, 1);
        this.updateVoiceCount();
      }, (decayTime + 0.05) * 1000);

      this.updateVoiceCount();
    } catch (error) {
      console.error('Sound error:', error);
    }
  }

  updateVoiceCount() {
    const display = document.getElementById('voice-count');
    if (display) {
      const count = this.activeOscillators.length;
      display.textContent = `${count}/${this.maxPolyphony}`;
    }
  }

  play() {
    if (this.isPlaying) return;

    this.isPlaying = true;
    this.currentStep = 0;

    if (this.audioContext?.state === 'suspended') {
      this.audioContext.resume();
    }

    const stepDuration = (60000 / this.bpm) / 4;

    this.intervalId = setInterval(() => {
      // Play active pads at current step
      for (let padIndex = 0; padIndex < 16; padIndex++) {
        if (this.sequencerData[padIndex][this.currentStep]) {
          this.playPad(padIndex);
        }
      }
      this.currentStep = (this.currentStep + 1) % 16;
    }, stepDuration);

    document.getElementById('play-btn').classList.add('playing');
    console.log('‚ñ∂Ô∏è Playing');
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }

    this.isPlaying = false;
    this.isRecording = false;
    this.currentStep = 0;

    document.getElementById('play-btn').classList.remove('playing');
    document.getElementById('record-btn').classList.remove('recording');

    console.log('‚èπÔ∏è Stopped');
  }

  toggleRecord() {
    this.isRecording = !this.isRecording;

    const btn = document.getElementById('record-btn');
    if (this.isRecording) {
      btn.classList.add('recording');
      if (!this.isPlaying) this.play();
      console.log('üî¥ Recording');
    } else {
      btn.classList.remove('recording');
      console.log('‚èπÔ∏è Record off');
    }
  }

  clearSequence() {
    if (!confirm('Clear sequence?')) return;

    for (let i = 0; i < 16; i++) {
      this.sequencerData[i] = new Array(16).fill(false);
    }

    console.log('üóëÔ∏è Cleared');
  }

  exportSequence() {
    const sequence = {
      name: `BeatPad_${Date.now()}`,
      bpm: this.bpm,
      bank: this.currentBank,
      data: this.sequencerData,
      created: new Date().toISOString()
    };

    const json = JSON.stringify(sequence, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `beatpad_${Date.now()}.json`;
    a.click();

    URL.revokeObjectURL(url);
    console.log('üíæ Exported');
  }

  setBPM(bpm) {
    this.bpm = Math.max(60, Math.min(200, bpm));
    document.getElementById('bpm-input').value = this.bpm;
    document.getElementById('header-bpm').textContent = this.bpm;

    if (this.isPlaying) {
      this.stop();
      this.play();
    }
  }

  setBank(bank) {
    this.currentBank = bank;
    console.log(`üéπ Bank: ${bank.toUpperCase()}`);
  }

  setupEventListeners() {
    // Transport
    document.getElementById('play-btn')?.addEventListener('click', () => this.play());
    document.getElementById('stop-btn')?.addEventListener('click', () => this.stop());
    document.getElementById('record-btn')?.addEventListener('click', () => this.toggleRecord());

    // BPM
    document.getElementById('bpm-up')?.addEventListener('click', () => this.setBPM(this.bpm + 1));
    document.getElementById('bpm-down')?.addEventListener('click', () => this.setBPM(this.bpm - 1));

    document.getElementById('bpm-input')?.addEventListener('change', (e) => {
      this.setBPM(parseInt(e.target.value) || 120);
    });

    // Bank
    document.getElementById('bank-select')?.addEventListener('change', (e) => {
      this.setBank(e.target.value);
    });

    // Actions
    document.getElementById('clear-btn')?.addEventListener('click', () => this.clearSequence());
    document.getElementById('export-btn')?.addEventListener('click', () => this.exportSequence());

    // Keyboard (Space = Play/Stop)
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

      if (e.code === 'Space') {
        e.preventDefault();
        if (this.isPlaying) this.stop();
        else this.play();
      }

      // Number keys 1-16 for pads
      if (e.key >= '1' && e.key <= '9') {
        const index = parseInt(e.key) - 1;
        this.playPad(index);
      }
    });
  }
}

/**
 * Strudel Integration
 */
class StrudelPlayer {
  constructor() {
    this.isPlaying = false;
    this.isPanelOpen = false;
    this.currentPattern = 'sound("bd sd")';
    this.strudelReady = false;
    this.cycle = 0;
    this.canvas = null;
    this.ctx = null;
    this.init();
  }

  async init() {
    // Check if Strudel is available
    this.strudelReady = !!window.strudel;

    this.setupControls();
    this.setupCanvas();

    if (this.strudelReady) {
      console.log('‚úÖ Strudel interface ready');
    } else {
      console.log('‚ö†Ô∏è Strudel interface ready (visualizer-only mode)');
    }
  }

  setupCanvas() {
    this.canvas = document.getElementById('strudel-canvas');
    if (this.canvas) {
      this.ctx = this.canvas.getContext('2d');
      this.canvas.width = this.canvas.offsetWidth;
      this.canvas.height = this.canvas.offsetHeight;
    }
  }

  togglePanel() {
    const panel = document.getElementById('strudel-panel');
    const toggle = document.getElementById('strudel-toggle');

    if (!panel) {
      console.error('‚ùå Strudel panel not found');
      return;
    }

    if (!toggle) {
      console.error('‚ùå Strudel toggle not found');
      return;
    }

    this.isPanelOpen = !this.isPanelOpen;

    if (this.isPanelOpen) {
      panel.classList.remove('collapsed');
      toggle.textContent = '‚ñ≤ STRUDEL CODE';
      console.log('üìñ Strudel panel opened');
    } else {
      panel.classList.add('collapsed');
      toggle.textContent = '‚ñº STRUDEL CODE';
      console.log('üìï Strudel panel closed');
    }
  }

  setupControls() {
    // Toggle panel
    const toggleBtn = document.getElementById('strudel-toggle');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => {
        console.log('Toggle clicked');
        this.togglePanel();
      });
      console.log('‚úÖ Strudel toggle button connected');
    } else {
      console.error('‚ùå Strudel toggle button not found');
    }

    // Playback controls
    document.getElementById('strudel-play')?.addEventListener('click', () => this.play());
    document.getElementById('strudel-stop')?.addEventListener('click', () => this.stop());

    // Load preset
    document.getElementById('strudel-load')?.addEventListener('click', () => {
      const select = document.getElementById('strudel-pattern');
      const code = document.getElementById('strudel-code');
      if (select && code) {
        code.value = select.value;
        this.currentPattern = select.value;
        this.updatePatternDisplay();
      }
    });

    // Reload samples
    document.getElementById('reload-samples')?.addEventListener('click', async () => {
      this.updateStatus('LOADING...');
      await window.strudel.preloadSamples?.();
      this.updateStatus('READY');
    });

    // Clear code
    document.getElementById('code-clear')?.addEventListener('click', () => {
      const code = document.getElementById('strudel-code');
      if (code) code.value = '';
    });

    // Code editor keyboard shortcuts
    const codeEditor = document.getElementById('strudel-code');
    if (codeEditor) {
      codeEditor.addEventListener('keydown', (e) => {
        // Ctrl+Enter to evaluate
        if (e.ctrlKey && e.key === 'Enter') {
          e.preventDefault();
          this.currentPattern = codeEditor.value;
          this.play();
        }
        // Esc to stop
        if (e.key === 'Escape') {
          e.preventDefault();
          this.stop();
        }
        // Tab for indentation
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = codeEditor.selectionStart;
          const end = codeEditor.selectionEnd;
          codeEditor.value = codeEditor.value.substring(0, start) + '  ' + codeEditor.value.substring(end);
          codeEditor.selectionStart = codeEditor.selectionEnd = start + 2;
        }
      });

      // Update pattern on change
      codeEditor.addEventListener('input', () => {
        this.currentPattern = codeEditor.value;
      });
    }
  }

  async play() {
    if (this.isPlaying) {
      this.stop();
      return;
    }

    this.updateStatus('LOADING...');

    try {
      // Use Strudel if available
      if (window.strudel?.evaluate) {
        await window.strudel.evaluate(this.currentPattern);
        this.isPlaying = true;
        this.updateStatus('PLAYING');
      } else {
        console.warn('Strudel not loaded, visualizer only mode');
        this.isPlaying = true;
        this.updateStatus('VIZ ONLY');
      }

      const btn = document.getElementById('strudel-play');
      if (btn) {
        btn.classList.add('playing');
        btn.textContent = '‚è∏ PAUSE';
      }

      this.updatePatternDisplay();
      this.cycle = 0;
      this.visualize();
      console.log('‚ñ∂Ô∏è Playing:', this.currentPattern);
    } catch (error) {
      console.error('Playback error:', error);
      this.updateStatus('ERROR: ' + error.message);
      // Still show visualizer even if Strudel fails
      this.isPlaying = true;
      this.visualize();
    }
  }

  stop() {
    try {
      if (window.strudel?.stop) {
        window.strudel.stop();
      }
      this.isPlaying = false;

      const btn = document.getElementById('strudel-play');
      if (btn) {
        btn.classList.remove('playing');
        btn.textContent = '‚ñ∂ PLAY';
      }

      this.updateStatus('STOPPED');
      console.log('‚èπÔ∏è Stopped');
    } catch (error) {
      console.error('Stop error:', error);
      this.isPlaying = false;
      this.updateStatus('STOPPED');
    }
  }

  updateStatus(status) {
    const statusEl = document.getElementById('strudel-status');
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.className = 'strudel-status ' + status.toLowerCase().split(':')[0];
    }
  }

  updatePatternDisplay() {
    const display = document.getElementById('pattern-display');
    if (!display) return;

    const lines = this.currentPattern.split('\n');
    let html = '<div class="pattern-text">';

    lines.forEach((line, i) => {
      const lineNum = (i + 1).toString().padStart(2, '0');
      html += `<div class="pattern-line">
        <span class="line-num">${lineNum}</span>
        <span class="line-code">${this.escapeHtml(line)}</span>
      </div>`;
    });

    html += '</div>';
    display.innerHTML = html;
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  visualize() {
    if (!this.canvas || !this.ctx) return;

    let frame = 0;
    const width = this.canvas.width;
    const height = this.canvas.height;

    const animate = () => {
      if (!this.isPlaying) return;

      frame++;
      this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      this.ctx.fillRect(0, 0, width, height);

      // Draw waveform
      const bars = 32;
      const barWidth = width / bars;

      for (let i = 0; i < bars; i++) {
        const barHeight = Math.sin(frame * 0.05 + i * 0.3) * (height / 3) +
                          Math.random() * (height / 4);
        const x = i * barWidth;
        const y = height - Math.abs(barHeight);

        // Color cycling
        const hue = (frame + i * 10) % 360;
        this.ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        this.ctx.fillRect(x, y, barWidth - 2, Math.abs(barHeight));

        // Glow effect
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
      }

      this.ctx.shadowBlur = 0;

      // Update cycle count
      if (frame % 60 === 0) {
        this.cycle++;
        const cycleEl = document.getElementById('viz-cycle');
        if (cycleEl) cycleEl.textContent = `CYCLE: ${this.cycle}`;
      }

      requestAnimationFrame(animate);
    };

    animate();
  }
}

// Simple Strudel-like pattern player using Web Audio API
function createSimpleStrudel() {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();

  /**
   * Sample Library System
   *
   * Strudel uses the SuperDirt sample library which includes:
   * - 808/909 drum machines
   * - Acoustic drums
   * - Bass sounds
   * - Synth sounds
   * - Vocal samples
   *
   * Official Strudel samples: https://github.com/tidalcycles/Dirt-Samples
   *
   * This implementation:
   * 1. Loads real 808 drum samples from local /wav/ directory
   * 2. Falls back to Web Audio synthesis if samples don't load
   * 3. Caches loaded samples for performance
   */
  // Use local WAV files from /public/wav/
  const sampleUrls = {
    // Drums
    bd: '/wav/bd.wav',
    sd: '/wav/sd.wav',
    hh: '/wav/hh.wav',
    ch: '/wav/hh.wav',    // Alias
    cp: '/wav/cp.wav',
    oh: '/wav/oh.wav',
    lt: '/wav/lt.wav',
    mt: '/wav/mt.wav',
    ht: '/wav/ht.wav',
    rim: '/wav/rim.wav',

    // Bass
    'bass-sub': '/wav/bass-sub.wav',
    'bass-acid': '/wav/bass-acid.wav',
    'bass-synth': '/wav/bass-synth.wav',
    'bass-reese': '/wav/bass-reese.wav',
    'bass-wobble': '/wav/bass-wobble.wav',

    // Phaser/FX
    'phaser': '/wav/phaser.wav',
    'filter-sweep': '/wav/filter-sweep.wav',
    'riser': '/wav/riser.wav',

    // Space/Ambient
    'pad': '/wav/pad.wav',
    'drone': '/wav/drone.wav',
    'laser': '/wav/laser.wav',
    'zap': '/wav/zap.wav',
    'cosmic': '/wav/cosmic.wav',
    'swoosh': '/wav/swoosh.wav',
  };

  // Audio buffer cache
  const bufferCache = {};
  const loadingSamples = {};

  // Load a sample into buffer
  async function loadSample(name, url) {
    if (bufferCache[name]) return bufferCache[name];
    if (loadingSamples[name]) return loadingSamples[name];

    loadingSamples[name] = fetch(url)
      .then(response => response.arrayBuffer())
      .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
      .then(buffer => {
        bufferCache[name] = buffer;
        delete loadingSamples[name];
        return buffer;
      })
      .catch(error => {
        console.warn(`Failed to load sample ${name}:`, error);
        delete loadingSamples[name];
        return null;
      });

    return loadingSamples[name];
  }

  // Preload common samples
  async function preloadSamples() {
    const commonSamples = ['bd', 'sd', 'hh', 'cp', 'oh', 'lt', 'mt', 'ht', 'rim'];
    console.log('üéµ Preloading 808 drum samples...');

    const results = await Promise.allSettled(
      commonSamples.map(async name => {
        const url = sampleUrls[name];
        if (!url) return null;
        const buffer = await loadSample(name, url);
        console.log(`  ${buffer ? '‚úÖ' : '‚ùå'} ${name.toUpperCase()}`);
        return buffer;
      })
    );

    const loaded = results.filter(r => r.status === 'fulfilled' && r.value).length;
    console.log(`‚úÖ Loaded ${loaded}/${commonSamples.length} samples`);
    console.log('üí° Using synthesis fallback for any missing samples');
  }

  // Start preloading
  preloadSamples();

  let currentInterval = null;
  let step = 0;

  window.strudel = {
    bufferCache,
    loadingSamples,
    preloadSamples,

    evaluate(code) {
      return new Promise((resolve) => {
        // Stop existing pattern
        this.stop();

        // Parse simple patterns like sound("bd sd") or note("c a f e").s("piano")
        const soundMatch = code.match(/sound\("([^"]+)"\)/);
        const noteMatch = code.match(/note\("([^"]+)"\).*s\("([^"]+)"\)/);
        const miniMatch = code.match(/s\("([^"]+)"\)/);

        let pattern = null;
        let tempo = 500; // ms per step

        if (soundMatch) {
          // Parse drum pattern
          const sounds = soundMatch[1].split(/[\s,]+/);
          pattern = sounds.map(s => {
            const parts = s.match(/(\w+)(\*(\d+))?/);
            if (!parts) return null;
            const sound = parts[1];
            const repeat = parts[3] ? parseInt(parts[3]) : 1;
            return { sound, repeat };
          }).filter(Boolean);
        } else if (noteMatch || miniMatch) {
          // Parse melodic pattern
          const notes = noteMatch ? noteMatch[1].split(/[\s,]+/) : [];
          const instrument = noteMatch ? noteMatch[2] : (miniMatch ? miniMatch[1].split(',')[0] : 'piano');

          if (notes.length > 0) {
            pattern = notes.map(note => ({ note, instrument }));
          } else {
            // Mini notation like s("bd sd,hh*8")
            const parts = (miniMatch[1] || '').split(',');
            pattern = parts[0].split(/[\s]+/).map(s => ({
              sound: s.replace(/\*\d+/, ''),
              repeat: (s.match(/\*(\d+)/) || [null, 1])[1]
            }));
          }
        }

        if (!pattern) {
          console.warn('Pattern not recognized, playing default');
          pattern = [{ sound: 'bd' }, { sound: 'sd' }];
        }

        // Play pattern
        step = 0;
        currentInterval = setInterval(() => {
          const current = pattern[step % pattern.length];

          if (current.sound) {
            this.playSound(current.sound);
          } else if (current.note) {
            this.playNote(current.note, current.instrument);
          }

          step++;
        }, tempo);

        console.log('‚úÖ Pattern playing:', code);
        resolve();
      });
    },

    async playSound(soundName) {
      const now = audioContext.currentTime;

      // Try to play sample first
      const buffer = bufferCache[soundName];
      if (buffer) {
        this.playSample(buffer, now);
        return;
      }

      // If sample is loading, wait for it
      if (loadingSamples[soundName]) {
        try {
          const loadedBuffer = await loadingSamples[soundName];
          if (loadedBuffer) {
            this.playSample(loadedBuffer, now);
            return;
          }
        } catch (e) {
          console.warn('Sample load failed, using synthesis');
        }
      }

      // If sample URL exists but not loaded, try to load it
      if (sampleUrls[soundName]) {
        loadSample(soundName, sampleUrls[soundName]).then(buffer => {
          if (buffer) {
            // Sample loaded, but too late for this trigger
            // It will be cached for next time
          }
        });
      }

      // Fallback to synthesis
      switch(soundName) {
        case 'bd':
          this.playKick(now);
          break;
        case 'sd':
          this.playSnare(now);
          break;
        case 'hh':
        case 'ch':
          this.playHiHat(now, 0.05);
          break;
        case 'oh':
          this.playHiHat(now, 0.15);
          break;
        case 'cp':
          this.playClap(now);
          break;
        case 'rim':
          this.playRim(now);
          break;
        case 'lt':
          this.playTom(now, 90);
          break;
        case 'mt':
          this.playTom(now, 130);
          break;
        case 'ht':
          this.playTom(now, 180);
          break;
        default:
          console.warn('Unknown sound:', soundName);
      }
    },

    // Play audio buffer sample
    playSample(buffer, time) {
      const source = audioContext.createBufferSource();
      const gain = audioContext.createGain();

      source.buffer = buffer;
      gain.gain.value = 0.8;

      source.connect(gain);
      gain.connect(audioContext.destination);

      source.start(time);
    },

    // Kick drum with punch and sub-bass
    playKick(time) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      const filter = audioContext.createBiquadFilter();

      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);

      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(200, time);
      filter.Q.value = 1;

      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.4);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(time);
      osc.stop(time + 0.4);
    },

    // Snare with noise burst - the "bap" sound
    playSnare(time) {
      // Noise component (snare wires)
      const bufferSize = audioContext.sampleRate * 0.2;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = noiseBuffer;

      const noiseFilter = audioContext.createBiquadFilter();
      noiseFilter.type = 'highpass';
      noiseFilter.frequency.value = 2000; // Bright, crispy

      const noiseGain = audioContext.createGain();
      noiseGain.gain.setValueAtTime(0.8, time);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.12);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(audioContext.destination);

      // Tone component (drum body)
      const osc = audioContext.createOscillator();
      osc.type = 'triangle';
      osc.frequency.value = 180;

      const oscGain = audioContext.createGain();
      oscGain.gain.setValueAtTime(0.4, time);
      oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

      osc.connect(oscGain);
      oscGain.connect(audioContext.destination);

      noise.start(time);
      noise.stop(time + 0.12);
      osc.start(time);
      osc.stop(time + 0.1);
    },

    // Hi-hat with metallic noise
    playHiHat(time, duration) {
      const bufferSize = audioContext.sampleRate * duration;
      const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }

      const noise = audioContext.createBufferSource();
      noise.buffer = noiseBuffer;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 7000; // Very bright

      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.3, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + duration);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      noise.start(time);
      noise.stop(time + duration);
    },

    // Clap - multiple noise bursts
    playClap(time) {
      for (let i = 0; i < 3; i++) {
        const delay = i * 0.015; // Slight delay between layers
        const bufferSize = audioContext.sampleRate * 0.08;
        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let j = 0; j < bufferSize; j++) {
          data[j] = Math.random() * 2 - 1;
        }

        const noise = audioContext.createBufferSource();
        noise.buffer = noiseBuffer;

        const filter = audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;

        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.4, time + delay);
        gain.gain.exponentialRampToValueAtTime(0.01, time + delay + 0.08);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioContext.destination);

        noise.start(time + delay);
        noise.stop(time + delay + 0.08);
      }
    },

    // Rim shot - sharp high click
    playRim(time) {
      const osc = audioContext.createOscillator();
      osc.type = 'square';
      osc.frequency.value = 1200;

      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

      osc.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(time);
      osc.stop(time + 0.05);
    },

    // Tom with pitched body
    playTom(time, freq) {
      const osc = audioContext.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq * 2, time);
      osc.frequency.exponentialRampToValueAtTime(freq, time + 0.08);

      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(0.6, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);

      osc.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(time);
      osc.stop(time + 0.3);
    },

    playNote(noteName, instrument) {
      const noteFreqs = {
        c: 261.63, d: 293.66, e: 329.63, f: 349.23,
        g: 392.00, a: 440.00, b: 493.88
      };

      const freq = noteFreqs[noteName.toLowerCase()] || 440;
      const sample = sampleBank[instrument] || { type: 'sine' };

      const now = audioContext.currentTime;
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = sample.type;
      osc.frequency.value = freq;

      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

      osc.connect(gain);
      gain.connect(audioContext.destination);

      osc.start(now);
      osc.stop(now + 0.5);
    },

    stop() {
      if (currentInterval) {
        clearInterval(currentInterval);
        currentInterval = null;
        step = 0;
      }
    }
  };

  console.log('‚úÖ Simple Strudel-compatible player ready');
  return true;
}

// Initialize
async function initBeatPad() {
  // Create simple Strudel-compatible player
  createSimpleStrudel();

  if (!window.beatPad) {
    window.beatPad = new BeatPad();
    console.log('‚úÖ Beat Pad initialized');
  }

  if (!window.strudelPlayer) {
    window.strudelPlayer = new StrudelPlayer();
  }
}

document.addEventListener('DOMContentLoaded', initBeatPad);
document.addEventListener('astro:page-load', initBeatPad);

if (document.readyState !== 'loading') {
  initBeatPad();
}
</script>

<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  .beat-pad-container {
    width: 100%;
    height: 100vh;
    background: #000;
    color: #0f0;
    font-family: 'Courier New', monospace;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    animation: crtFlicker 0.15s infinite;
  }

  /* CRT Flicker Effect */
  @keyframes crtFlicker {
    0% { opacity: 1; }
    50% { opacity: 0.98; }
    100% { opacity: 1; }
  }

  /* Random flicker pulses */
  @keyframes crtPulse {
    0%, 90%, 100% { opacity: 1; }
    93% { opacity: 0.92; }
    96% { opacity: 0.88; }
  }

  /* Retro Header - Minimal */
  .retro-header {
    background: #000;
    border-bottom: 3px solid #0f0;
    padding: 0.75rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
    flex-wrap: wrap;
    gap: 1rem;
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 2rem;
  }

  /* Strudel Toggle Button */
  .strudel-display {
    display: flex;
    align-items: center;
  }

  .strudel-toggle {
    padding: 0.5rem 1.5rem;
    background: #000;
    border: 2px solid #0ff;
    color: #0ff;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    letter-spacing: 1px;
  }

  .strudel-toggle:hover {
    background: #0ff;
    color: #000;
    box-shadow: 0 0 20px #0ff;
  }

  /* Strudel Panel (Expandable) */
  .strudel-panel {
    background: #000;
    border-bottom: 3px solid #0ff;
    transition: all 0.3s ease-out;
    max-height: 500px;
    overflow: hidden;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
  }

  .strudel-panel.collapsed {
    max-height: 0;
    border-bottom-width: 0;
    box-shadow: none;
  }

  .strudel-panel-inner {
    padding: 1rem 1.5rem;
  }

  /* Controls Row */
  .strudel-controls-row {
    display: flex;
    gap: 1.5rem;
    align-items: center;
    padding: 0.75rem;
    background: rgba(0, 255, 255, 0.05);
    border: 2px solid #0ff;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .strudel-label {
    color: #0ff;
    font-weight: 700;
    font-size: 0.75rem;
    letter-spacing: 1px;
  }

  .strudel-btn {
    padding: 0.5rem 1rem;
    background: #000;
    border: 2px solid #0ff;
    color: #0ff;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
  }

  .strudel-btn:hover {
    background: #0ff;
    color: #000;
    box-shadow: 0 0 15px #0ff;
    transform: translateY(-1px);
  }

  .strudel-btn.playing {
    background: #0ff;
    color: #000;
    animation: strudelPulse 1s infinite;
  }

  @keyframes strudelPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .strudel-select {
    padding: 0.5rem 0.75rem;
    background: #000;
    border: 2px solid #0ff;
    color: #0ff;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 0.75rem;
    cursor: pointer;
    min-width: 150px;
  }

  .strudel-status {
    padding: 0.5rem 1rem;
    background: rgba(0, 255, 255, 0.1);
    border: 2px solid #0ff;
    color: #0ff;
    font-weight: 700;
    font-size: 0.75rem;
    letter-spacing: 1px;
  }

  .strudel-status.playing {
    background: rgba(0, 255, 0, 0.1);
    border-color: #0f0;
    color: #0f0;
    animation: statusPulse 1s infinite;
  }

  .strudel-status.error {
    background: rgba(255, 0, 0, 0.1);
    border-color: #f00;
    color: #f00;
  }

  @keyframes statusPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }

  /* Main Content: Code + Visualizer */
  .strudel-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  /* Code Editor Section */
  .strudel-code-section {
    display: flex;
    flex-direction: column;
    border: 2px solid #0ff;
    background: rgba(0, 255, 255, 0.02);
  }

  .code-header,
  .viz-header {
    padding: 0.5rem 1rem;
    background: rgba(0, 255, 255, 0.1);
    border-bottom: 2px solid #0ff;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .code-label,
  .viz-label {
    color: #0ff;
    font-weight: 900;
    font-size: 0.875rem;
    letter-spacing: 2px;
    text-shadow: 0 0 10px #0ff;
  }

  .viz-cycle {
    color: #0ff;
    font-weight: 700;
    font-size: 0.75rem;
    opacity: 0.7;
  }

  .code-btn {
    padding: 0.25rem 0.75rem;
    background: #000;
    border: 1px solid #0ff;
    color: #0ff;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 0.625rem;
    cursor: pointer;
    transition: all 0.2s;
  }

  .code-btn:hover {
    background: #0ff;
    color: #000;
  }

  .strudel-code-editor {
    flex: 1;
    min-height: 200px;
    background: #000;
    color: #0ff;
    border: none;
    padding: 1rem;
    font-family: 'Courier New', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    resize: none;
    outline: none;
  }

  .strudel-code-editor::selection {
    background: #0ff;
    color: #000;
  }

  .code-footer {
    padding: 0.5rem 1rem;
    background: rgba(0, 255, 255, 0.05);
    border-top: 1px solid rgba(0, 255, 255, 0.3);
  }

  .code-hint {
    color: #0ff;
    font-size: 0.625rem;
    opacity: 0.6;
  }

  /* Visualizer Section */
  .strudel-viz-section {
    display: flex;
    flex-direction: column;
    border: 2px solid #0ff;
    background: rgba(0, 255, 255, 0.02);
  }

  .strudel-viz {
    height: 200px;
    background: #000;
    position: relative;
    overflow: hidden;
  }

  .strudel-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .strudel-pattern-display {
    flex: 1;
    background: rgba(0, 0, 0, 0.8);
    padding: 1rem;
    overflow-y: auto;
    max-height: 150px;
    border-top: 2px solid #0ff;
  }

  .pattern-text {
    font-family: 'Courier New', monospace;
    font-size: 0.75rem;
    color: #0ff;
    line-height: 1.6;
  }

  .pattern-line {
    display: flex;
    gap: 1rem;
    margin-bottom: 0.25rem;
  }

  .line-num {
    color: rgba(0, 255, 255, 0.4);
    min-width: 30px;
    text-align: right;
  }

  .line-code {
    color: #0ff;
    flex: 1;
  }

  .retro-title {
    font-size: 1.5rem;
    font-weight: 900;
    letter-spacing: 4px;
    color: #0f0;
    text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
    animation: titleGlow 2s ease-in-out infinite;
  }

  @keyframes titleGlow {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  .score-display {
    font-size: 1.25rem;
    font-weight: 700;
    color: #0ff;
    text-shadow: 0 0 5px #0ff;
  }

  .header-nav {
    display: flex;
    gap: 0.5rem;
  }

  .nav-btn {
    padding: 0.5rem 1rem;
    background: #000;
    border: 2px solid #0f0;
    color: #0f0;
    text-decoration: none;
    font-weight: 700;
    font-size: 0.875rem;
    letter-spacing: 1px;
    transition: all 0.2s;
    box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
  }

  .nav-btn:hover {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 15px #0f0;
    transform: translateY(-2px);
  }

  /* Main Pad Area - Maximum Space */
  .pad-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1rem;
    gap: 1rem;
    overflow: hidden;
  }

  /* Compact Controls Strip */
  .controls-strip {
    display: flex;
    gap: 1rem;
    padding: 0.75rem;
    background: rgba(0, 255, 0, 0.05);
    border: 2px solid #0f0;
    border-radius: 0;
    flex-wrap: wrap;
    align-items: center;
  }

  .control-group {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .ctrl-btn {
    width: 50px;
    height: 50px;
    background: #000;
    border: 2px solid #0f0;
    color: #0f0;
    font-size: 1.5rem;
    font-weight: 900;
    cursor: pointer;
    transition: all 0.1s;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
  }

  .ctrl-btn:hover {
    background: #0f0;
    color: #000;
    box-shadow: 0 0 20px #0f0;
    transform: scale(1.05);
  }

  .ctrl-btn:active {
    transform: scale(0.95);
  }

  .ctrl-btn.small {
    width: 40px;
    height: 40px;
    font-size: 1.25rem;
  }

  .ctrl-btn.playing {
    background: #0f0;
    color: #000;
    animation: buttonPulse 1s infinite;
  }

  .ctrl-btn.record.recording {
    background: #f00;
    border-color: #f00;
    color: #fff;
    animation: recordPulse 1s infinite;
  }

  @keyframes buttonPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  @keyframes recordPulse {
    0%, 100% { box-shadow: 0 0 10px #f00; }
    50% { box-shadow: 0 0 30px #f00; }
  }

  #bpm-input {
    width: 70px;
    height: 40px;
    background: #000;
    border: 2px solid #0f0;
    color: #0f0;
    font-family: 'Courier New', monospace;
    font-size: 1.25rem;
    font-weight: 700;
    text-align: center;
    padding: 0.25rem;
  }

  .bank-select {
    height: 40px;
    padding: 0 0.75rem;
    background: #000;
    border: 2px solid #0f0;
    color: #0f0;
    font-family: 'Courier New', monospace;
    font-weight: 700;
    font-size: 0.875rem;
    cursor: pointer;
  }

  .voices {
    font-size: 1rem;
    font-weight: 700;
    color: #0ff;
  }

  /* Pads Grid - Maximum Space */
  .pads-grid {
    flex: 1;
    display: grid !important;
    grid-template-columns: repeat(4, 1fr) !important;
    grid-template-rows: repeat(4, 1fr) !important;
    gap: 1rem;
    width: 100%;
    max-width: 100%;
  }

  .pad {
    width: 100%;
    height: 100%;
    min-height: 80px;
    background: radial-gradient(circle at center,
      #ffffff,
      #f5f5f5);
    border: 5px solid var(--border-color, #FFD700);
    display: flex !important;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    overflow: visible;
    transition: all 0.2s;
    box-shadow:
      0 0 20px var(--border-color, #FFD700),
      0 0 40px var(--border-color, #FFD700),
      inset 0 0 20px rgba(255, 215, 0, 0.2);
    animation: crtPulse 4s infinite;
  }

  /* Gold glow effect behind pad */
  .pad-glow {
    position: absolute;
    inset: -15px;
    background: radial-gradient(
      circle,
      var(--border-color, #FFD700) 0%,
      transparent 60%
    );
    opacity: 0.5;
    pointer-events: none;
    animation: glowPulse 2s ease-in-out infinite;
    filter: blur(20px);
    z-index: 0;
  }

  @keyframes glowPulse {
    0%, 100% { opacity: 0.5; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.15); }
  }

  .pad::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at center,
      var(--border-color, #FFD700) 0%,
      transparent 80%);
    opacity: 0.1;
    transition: all 0.2s;
    z-index: 1;
    pointer-events: none;
  }

  .pad:hover {
    border-width: 6px;
    transform: scale(1.05);
    box-shadow:
      0 0 30px var(--border-color, #FFD700),
      0 0 60px var(--border-color, #FFD700),
      0 0 90px var(--border-color, #FFD700),
      inset 0 0 30px rgba(255, 215, 0, 0.3);
  }

  .pad:hover::before {
    opacity: 0.3;
  }

  .pad:hover .pad-glow {
    opacity: 1;
    transform: scale(1.3);
  }

  .pad.selected {
    border-width: 7px;
    box-shadow:
      0 0 40px var(--border-color, #FFD700),
      0 0 70px var(--border-color, #FFD700),
      inset 0 0 40px rgba(255, 215, 0, 0.4);
    animation: selectedPulse 1s ease-in-out infinite;
  }

  @keyframes selectedPulse {
    0%, 100% {
      box-shadow:
        0 0 40px var(--border-color, #FFD700),
        0 0 70px var(--border-color, #FFD700),
        inset 0 0 40px rgba(255, 215, 0, 0.4);
    }
    50% {
      box-shadow:
        0 0 60px var(--border-color, #FFD700),
        0 0 100px var(--border-color, #FFD700),
        inset 0 0 60px rgba(255, 215, 0, 0.6);
    }
  }

  .pad.active {
    transform: scale(0.95);
    box-shadow:
      0 0 80px var(--border-color, #FFD700),
      0 0 120px var(--border-color, #FFD700),
      0 0 160px var(--border-color, #FFD700),
      inset 0 0 60px rgba(255, 215, 0, 0.6);
    border-width: 8px;
  }

  .pad.active::before {
    opacity: 0.5;
    background: radial-gradient(circle at center,
      var(--border-color, #FFD700) 0%,
      transparent 70%);
  }

  .pad.active .pad-inner {
    color: #333;
  }

  .pad.active .pad-glow {
    opacity: 1;
    transform: scale(1.5);
  }

  .pad-inner {
    position: relative;
    z-index: 9999;
    text-align: center;
    color: #333;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    pointer-events: none;
  }

  .pad-num {
    font-size: 2.5rem;
    font-weight: 900;
    line-height: 1;
    letter-spacing: 2px;
    color: #222;
  }

  .pad-name {
    font-size: 0.875rem;
    font-weight: 700;
    letter-spacing: 2px;
    margin-top: 0.5rem;
    color: #444;
  }

  /* Scanline Effect */
  .beat-pad-container::before {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 255, 0, 0.03) 2px,
      rgba(0, 255, 0, 0.03) 4px
    );
    pointer-events: none;
    animation: scanline 8s linear infinite;
  }

  @keyframes scanline {
    0% { transform: translateY(0); }
    100% { transform: translateY(100%); }
  }

  /* Responsive */
  @media (max-width: 1024px) {
    .retro-title {
      font-size: 1.25rem;
      letter-spacing: 2px;
    }

    .score-display {
      font-size: 1rem;
    }

    .pad-num {
      font-size: 2rem;
    }

    .pad-name {
      font-size: 0.75rem;
    }

    .strudel-content {
      grid-template-columns: 1fr;
    }

    .strudel-panel {
      max-height: 600px;
    }
  }

  @media (max-width: 768px) {
    .retro-header {
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
    }

    .header-left {
      flex-direction: column;
      gap: 0.5rem;
    }

    .controls-strip {
      padding: 0.5rem;
      gap: 0.5rem;
    }

    .pads-grid {
      gap: 0.5rem;
    }

    .pad-num {
      font-size: 1.5rem;
    }

    .pad-name {
      font-size: 0.625rem;
    }

    .nav-btn {
      padding: 0.375rem 0.75rem;
      font-size: 0.75rem;
    }
  }

  @media (max-height: 700px) {
    .pad-num {
      font-size: 1.75rem;
    }

    .pad-name {
      font-size: 0.7rem;
    }

    .controls-strip {
      padding: 0.5rem;
    }

    .pads-grid {
      gap: 0.75rem;
    }
  }
</style>
